TODO: 
[ ] multi language support through server API 
[ ] built in database which isolates stored user data that is not meant to interact with the
----- underlying system 

[ ] Implement command EXIT and ABORT methods --> when the user indicates to vcs_core that 
----- she/he is finished with the commnand a keyword is spoken, which triggers the command channel 
----- to call its EXIT method, which ?returns a value that is then piped to the stack ? 



Command Ideas 
------------- 

=> NIGHT REVIEW / SEQUENCE COMMANDS 
---- 3 EVENTS / PEOPLE I AM GRATEFUL FOR THAT DAY 
---- The BEST THING THAT HAPPENED THAT DAY
---- REVIEW OF PREVIOUS DREAMS 
---- REVIEW OF BEST THINGS / GRATITUDE 


=> RECORD DREMS 

IT IS SO IMPORTANT TO DREAM!!! "wouldnt that be nice" 
WHAT DO I WANT TO DO
WHAT WOULD IT BE LIKE IF I 




[Tue Mar 26 07:05:31 PDT 2019]
// TODO (DONE)  ! 
// need to initialize the command with config (really means instantiate it) 
// once the command is initialized we will place it on the top of the command stack
// perhaps the command can have an sink channel which it finally writes to 

/// vcs_core_initialize_command -> instantiates it, puts it on stack, gives it the input 
/// channel of the current highest command on the stack  TO RETURN TO 
/// when a command is instantiated it either HAS a return port or it does not 
/// this should be handled behind the scenese i.e.    this.finish({ result }) , which 
/// if available will return the result on the proper channel 

// the command base class has an async function call_command  , which behind the hood: 
// -- does the same as above by using vcs_core to init a command 
// -- listens on the calling commands INPUT port for the response then returns the result

[x] Implement a vcs_repl for testing the commands 
[x] FIX OPTIONALS before and after space... e.g. "?(PLEASE )append to ..." 





[Sun Mar 10 22:31:24 PDT 2019] ----------------------------------------


- write command base class [each cmd has unique key trailing ID to allow multiple instances]
- write dispatch builder (spoiler... its another vcs command :)  

- When an input is read on vcs_core.input channel, one of two things happens
1) if there are commands in the command stack, it is sent to the TOP command's channel 
2) if there are no commands, a search is done for a matching command : 
--- a) if one is found, then the DISPATCH BUILDER command is loaded onto the stack 
--- b) if none, then ERROR 

- WHEN any command returns {err  , result} it is popped off the stack and the return is 
- piped into the NEXT command channel on the stack, if one exists. If not, is ?discarded  

- Once dispatch builder has the required args, it will call the approprate command via this.vcs_.core (see below), thereby pushing it to the stack 

- in this way, ALL commands return back to dispatch builder, and their results are essentially meaningless. THE MEANING IS IN THE SIDE EFFECT 

- command base class should have state object which holds mutable state of command 
- when a command calls another command it does so through VCS_core 
-- the command does: let {err, result} = await this.vcs_core.call_command(id,config)
-- behind the scenes vcs_core will INSTANTIATE the other command, and 
-- push its CHANNEL onto the "channel stack"


Command attributes: 
- channel , which has attribute
--- filter ~> key,value pairs for transforming the messages on the channel 

MODULARITY
- Filters are defined in modules 
- commands are defined in modules 

 ---------------------------------------- ----------------------------------------



FUTURE 
Move HTML/CSS content to NODEJS html server 
Can have channels outside of of the channel stack, by duplicating the vcs_core.input channel
-- these can ALSO listen in on the incoming text and respond to it arbitratily, allowing for 
-- asynchronous/ simultanous running commands 

