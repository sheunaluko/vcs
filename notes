TODO: 
[ ] finish implementing aliases ... namely , loading the aliases at program start as well as reload them during runtime. .bashrc? what abstraction?
[ ] multi language support through server API 
[ ] built in database which isolates stored user data that is not meant to interact with the
----- underlying system 

[ ] Implement command EXIT and ABORT methods AND REPEAT cmd --> when the user indicates to vcs_core that 
----- she/he is finished with the commnand a keyword is spoken, which triggers the command channel 
----- to call its EXIT method, which ?returns a value that is then piped to the stack ? 

-- wrapper around util.format BUILT into JS logger 

- in future will WANT a way of SHARING parameters accross the various programming languages. One way to do this is for the csi_adapter to receive a response containing 
- the current parameters when it registers. Then, whenever a parameter is changed a WEBSOCKET message is forwarded to all clients to notify them of the change 
- finally, parameters are stored in the db and are loaded at init time 


[ ] transcrypt to compile python commands to JS for producing a USER snapshot build JS file , create NPM tool with vcs.json file for compiling / project management etc , 
-- for transpilation, figure out how to modify base_command.py so that when it is compiled it automatically will integrate with JS VCS - that way other python commands 
-- can remain as they are
[ ]  set variables like current mouse location as m1 - then can dynamically link commands like "go" to "click m1" 
[ ]  the above "dynamic links" are like dynamic aliases which only are in memory and not stored to DB 


Command Ideas 
------------- 
=> command for VALIDATING input, which accepts as an argument a form of argument mapping 
---- as well, which can be used as a sub cmd 

=> youtube-dl  (uses statehub to upgrade youtube-dl etc) 

=> NIGHT REVIEW / SEQUENCE COMMANDS 
---- 3 EVENTS / PEOPLE I AM GRATEFUL FOR THAT DAY 
---- The BEST THING THAT HAPPENED THAT DAY
---- REVIEW OF PREVIOUS DREAMS 
---- REVIEW OF BEST THINGS / GRATITUDE 


=> RECORD DREMS 

IT IS SO IMPORTANT TO DREAM!!! "wouldnt that be nice" 
WHAT DO I WANT TO DO
WHAT WOULD IT BE LIKE IF I 

[ ] command for dictating changes to source code in case should be review later 
[ ] ENCRYPTED log, which can only be read with a password 




TO THINK ABOUT : 
SHould the alias be applied ONLY WHEN SEARCHING FOR COMMAND TO RUN ?

[Tue Mar 26 07:05:31 PDT 2019]
// TODO (DONE)  ! 
// need to initialize the command with config (really means instantiate it) 
// once the command is initialized we will place it on the top of the command stack
// perhaps the command can have an sink channel which it finally writes to 

/// vcs_core_initialize_command -> instantiates it, puts it on stack, gives it the input 
/// channel of the current highest command on the stack  TO RETURN TO 
/// when a command is instantiated it either HAS a return port or it does not 
/// this should be handled behind the scenese i.e.    this.finish({ result }) , which 
/// if available will return the result on the proper channel 

// the command base class has an async function call_command  , which behind the hood: 
// -- does the same as above by using vcs_core to init a command 
// -- listens on the calling commands INPUT port for the response then returns the result

[x] Implement a vcs_repl for testing the commands 
[x] FIX OPTIONALS before and after space... e.g. "?(PLEASE )append to ..." 





[Sun Mar 10 22:31:24 PDT 2019] ----------------------------------------


- write command base class [each cmd has unique key trailing ID to allow multiple instances]
- write dispatch builder (spoiler... its another vcs command :)  

- When an input is read on vcs_core.input channel, one of two things happens
1) if there are commands in the command stack, it is sent to the TOP command's channel 
2) if there are no commands, a search is done for a matching command : 
--- a) if one is found, then the DISPATCH BUILDER command is loaded onto the stack 
--- b) if none, then ERROR 

- WHEN any command returns {err  , result} it is popped off the stack and the return is 
- piped into the NEXT command channel on the stack, if one exists. If not, is ?discarded  

- Once dispatch builder has the required args, it will call the approprate command via this.vcs_.core (see below), thereby pushing it to the stack 

- in this way, ALL commands return back to dispatch builder, and their results are essentially meaningless. THE MEANING IS IN THE SIDE EFFECT 

- command base class should have state object which holds mutable state of command 
- when a command calls another command it does so through VCS_core 
-- the command does: let {err, result} = await this.vcs_core.call_command(id,config)
-- behind the scenes vcs_core will INSTANTIATE the other command, and 
-- push its CHANNEL onto the "channel stack"


Command attributes: 
- channel , which has attribute
--- filter ~> key,value pairs for transforming the messages on the channel 

MODULARITY
- Filters are defined in modules 
- commands are defined in modules 

 ---------------------------------------- ----------------------------------------



FUTURE 
Move HTML/CSS content to NODEJS html server 
Can have channels outside of of the channel stack, by duplicating the vcs_core.input channel
-- these can ALSO listen in on the incoming text and respond to it arbitratily, allowing for 
-- asynchronous/ simultanous running commands 

